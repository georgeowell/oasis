diff --git a/node_modules/ssb-config/.travis.yml b/node_modules/ssb-config/.travis.yml
index 7b0a3a5..2d3ec39 100644
--- a/node_modules/ssb-config/.travis.yml
+++ b/node_modules/ssb-config/.travis.yml
@@ -1,2 +1,9 @@
 language: node_js
 node_js: lts/*
+sudo: required
+before_script:
+  # Add an IPv6 config - see the corresponding Travis issue
+  # https://github.com/travis-ci/travis-ci/issues/8361
+  - if [ "${TRAVIS_OS_NAME}" == "linux" ]; then
+      sudo sh -c 'echo 0 > /proc/sys/net/ipv6/conf/all/disable_ipv6';
+    fi
diff --git a/node_modules/ssb-config/README.md b/node_modules/ssb-config/README.md
index 97ad7f2..e023f00 100644
--- a/node_modules/ssb-config/README.md
+++ b/node_modules/ssb-config/README.md
@@ -43,7 +43,7 @@ returns you the stock standard config for starting an `ssb-server`
 
 A function which takes:
 - `appName` *(string)* which declares where to look for further config, where to read and write databases. Stores data in `~/.${appName}`, defaults to `ssb` (so data in `~/.ssb`).
-- `opts` *(object)* an object which is fed into the config generation as a bunch of defaults (see 'Configuration' below)
+- `opts` *(object)* an object which can override config defaults (see 'Configuration' below)
 
 ## Configuration
 
@@ -59,7 +59,7 @@ Options:
 * `friends.hops` *(number)* How many friend of friend hops to replicate. Defaults to `3`.
 * `gossip` *(object)* controls what sort of connections are made (see below)
 * `path` *(string)* Path to the application data folder, which contains the private key, message attachment data (blobs) and the leveldb backend. Defaults to `$HOME/.ssb`.
-* `master` *(array)* Pubkeys of users who, if they connect to the Scuttlebot instance, are allowed to command the primary user with full rights. Useful for remotely operating a pub. Defaults to `[]`.
+* `master` *(array)* Pubkeys of users who, if they connect to the [ssb-server](https://github.com/ssbc/ssb-server) instance, are allowed to command the primary user with full rights. Useful for remotely operating a pub. Defaults to `[]`.
 * `logging.level` *(string)* How verbose should the logging be. Possible values are error, warning, notice, and info. Defaults to `notice`.
 * `party` _(boolean)_ TODO
 * `timers.connection` _(number)_ TODO
@@ -70,8 +70,8 @@ Options:
 * `caps.sign` _(string)_ Used to sign messages
 
 Deprecated Options:
-* `host` *(string)* The domain or ip address for `sbot`. Defaults to your public ip address.
-* `port` *(string|number)* The port for `sbot`. Defaults to `8008`.
+* `host` *(string)* The domain or ip address for [ssb-server](https://github.com/ssbc/ssb-server). Defaults to your public ip address.
+* `port` *(string|number)* The port for [ssb-server](https://github.com/ssbc/ssb-server). Defaults to `8008`.
 * `ws` TODO
 
 You should use `connections` to more explicitly configure connections.
@@ -122,11 +122,11 @@ An address scope is the area from which it's possible to connect to an address.
 * `local` means connections can only come from the same network, i.e. same wifi.
 * `public` means connections can come from anywhere on the internet.
 
-Some protocols only work in particular scopes. `unix` socket requires fs access,
+Some protocols only work in particular scopes. `unix` socket requires file system access,
 so it only works for the device scope. `onion` (tor) routes connections through a distributed network,
 so it only works if you are fully connected to the `public` internet. Some mesh networks
-are really large, so they might seem public. Some overlay networks, such as cjdns and
-ZeroTeirOne create a fake local network that is publically accessable (these should
+are really large, so they might seem public. Some overlay networks, such as [cjdns](https://github.com/cjdelisle/cjdns/) and
+[ZeroTier](https://www.zerotier.com/) create a fake local network that is publically accessible (these should
 be manually configured as public addresses!)
 
 most ssb peers just have a local and device scopes. pubs require a public scope.
@@ -149,7 +149,7 @@ If you only want to use [Tor](https://torproject.org) to create outgoing connect
 }
 ```
 
-If you want to run a peer behind NAT or other kind of proxy but still want sbot to be able to create invites for the outside addres, you can specify a `public` scope as your `incoming.net` by defining the `external` parameter like this:
+If you want to run a peer behind NAT or other kind of proxy but still want [ssb-server](https://github.com/ssbc/ssb-server) to be able to create invites for the outside address, you can specify a `public` scope as your `incoming.net` by defining the `external` parameter like this:
 
 ```json
 { 
@@ -167,7 +167,7 @@ If you want to run a peer behind NAT or other kind of proxy but still want sbot
 
 One thing to notice is that you _need_ `incoming` connections for Apps (like patchwork or git-ssb) to function. By default they use the same authentication mechanism (shs) to grant access to the database, choosing access levels depending on the keypair that opens the connection. If you connect to yourself, you get full access (query and publish). If a remote peer connects, it can only replicate. So be sure to have **at least one** `incoming` connection.
 
-That being said, the overhead of encryption for local applications can be very high, especially on low-powered devices. For this use-case there is a `noauth` transform which by-passes the authentication and grants full access to anybody that can connect to it. **hint:** *This is risky! it might expose private messages or enables people to publish as you!* Therefore be sure to bind the listener to `localhost` or use the `unix` socket. The `unix` file socket is creted as `$HOME/.ssb/socket` by default and has permissions such that only the user running `sbot server` can open it, just like the `.ssb/secret` file.
+That being said, the overhead of encryption for local applications can be very high, especially on low-powered devices. For this use-case there is a `noauth` transform which by-passes the authentication and grants full access to anybody that can connect to it. **hint:** *This is risky! it might expose private messages or enables people to publish as you!* Therefore be sure to bind the listener to `localhost` or use the `unix` socket. The `unix` file socket is created as `$HOME/.ssb/socket` by default and has permissions such that only the user running `ssb-server start` can open it, just like the `$HOME/.ssb/secret` file.
 
 ```json
 { 
@@ -181,7 +181,7 @@ That being said, the overhead of encryption for local applications can be very h
 }
 ```
 
-The local plugin inside scuttlebot will use the first incoming connection of either public or private scope. 
+The local plugin inside [ssb-server](https://github.com/ssbc/ssb-server) will use the first incoming connection of either public or private scope. 
 
 ## `gossip`
 
diff --git a/node_modules/ssb-config/defaults.js b/node_modules/ssb-config/defaults.js
index ae48077..b9ac854 100644
--- a/node_modules/ssb-config/defaults.js
+++ b/node_modules/ssb-config/defaults.js
@@ -3,9 +3,10 @@ var home = require('os-homedir')
 var merge = require('deep-extend')
 var ssbCaps = require('ssb-caps')
 var ssbKeys = require('ssb-keys')
+const get = require('lodash.get')
 
-var incomingConnections = require('./util/incoming-connections')
 var fixConnections = require('./util/fix-connections')
+const defaultPorts = require('./default-ports')
 
 var SEC = 1e3
 var MIN = 60 * SEC
@@ -19,15 +20,15 @@ module.exports = function setDefaults (name, config) {
     local: true,
     friends: {
       dunbar: 150,
-      hops: 3
+      hops: 2
     },
     gossip: {
       connections: 3
     },
     connections: {
       outgoing: {
-        net: [{ transform: 'shs' }],
-        onion: [{ transform: 'shs' }]
+	net: [{ transform: 'shs' }],
+	onion: [{ transform: 'shs' }]
       }
     },
     timers: {
@@ -46,7 +47,20 @@ module.exports = function setDefaults (name, config) {
   if (!config.connections.incoming) {
     // if no incoming connections have been set,
     // populate this with some rad-comprehensive defaults!
-    config.connections.incoming = incomingConnections(config)
+    config.connections.incoming = {
+      net: [{
+	host: config.host || '::',
+	port: config.port || defaultPorts.net,
+	scope: ['device', 'local', 'public'],
+	transform: 'shs'
+      }],
+      ws: [{
+	host: config.host || '::',
+	port: get(config, 'ws.port', defaultPorts.ws),
+	scope: ['device', 'local', 'public'],
+	transform: 'shs'
+      }]
+    }
   }
 
   config = fixConnections(config)
diff --git a/node_modules/ssb-config/ssb-config-3.4.3.tgz b/node_modules/ssb-config/ssb-config-3.4.3.tgz
new file mode 100644
index 0000000..e5e1e37
Binary files /dev/null and b/node_modules/ssb-config/ssb-config-3.4.3.tgz differ
diff --git a/node_modules/ssb-config/util/incoming-connections.js b/node_modules/ssb-config/util/incoming-connections.js
deleted file mode 100644
index c3979c5..0000000
--- a/node_modules/ssb-config/util/incoming-connections.js
+++ /dev/null
@@ -1,110 +0,0 @@
-const get = require('lodash.get')
-const os = require('os')
-const defaultPorts = require('../default-ports')
-const ip = require('ip')
-
-// generates all possible incoming connection settings that you could bind to
-module.exports = function (config) {
-  var incoming
-
-  // We have to deal with some legacy behavior where:
-  //
-  // - net port is defined by `config.port`
-  // - ws port is defined by `config.ws.port`
-  // - other services have no canonical port config location (TODO?)
-  const getPort = (service) => {
-    const defaultPort = defaultPorts[service]
-
-    if (service === 'net') {
-      return get(config, 'port', defaultPort)
-    }
-    if (service === 'ws') {
-      return get(config, 'ws.port', defaultPort)
-    }
-
-    return defaultPort
-  }
-
-
-  //legacy configuration didn't have a scopes concept,
-  //so interpret that as every scope at once.
-  //I think there is probably a better way to do this,
-  //but am fairly sure this will probably work.
-  const allScopes = ['device', 'local', 'public']
-
-  // If `config.host` is defined then we don't need to enumerate interfaces.
-  if (config.host) {
-    incoming = {
-      net: [{
-        host: config.host,
-        port: getPort('net'),
-        scope: allScopes,
-        transform: 'shs'
-      }],
-      ws: [{
-        host: config.host,
-        port: getPort('ws'),
-        scope: allScopes,
-        transform: 'shs'
-      }]
-    }
-  } else {
-    // Trying to hardcode reasonable defaults here doesn't seem possible.
-    //
-    // Instead, the below code enumerates all network interfaces and adds them
-    // to `config.connections.incoming` for each service in `defaultPorts`.
-
-    // If you aren't familiar, you should at least skim these docs:
-    // https://nodejs.org/api/os.html#os_os_networkinterfaces
-    const interfaces = os.networkInterfaces()
-
-    // Game plan: we're going to enumerate the services (e.g. net and ws) and
-    // return an object that looks like this:
-    //
-    // {
-    //   net: [ interface, interface, ... ]
-    //   ws: [ interface, interface, ... ]
-    // }
-    incoming = Object.keys(defaultPorts).map((service) => {
-      return {
-        service,
-        interfaces: Object.values(interfaces).reduce((acc, val) => {
-          // Future TODO: replace with shiny new `Array.prototype.flat()`.
-          return acc.concat(val)
-        }, []).filter(item => {
-          // We want to avoid scoped IPv6 addresses since they don't seem to
-          // play nicely with the Node.js networking stack. These addresses
-          // often start with `fe80` and throw EINVAL when we try to bind to
-          // them.
-          return item.scopeid == null || item.scopeid === 0
-        }).map(item => {
-          // This bit is simple because the ssb-config options for `incoming`
-          // can either be hardcoded or directly inferred from `interfaces`.
-
-          //if an interface is internal, it can only be accessed from the device.
-          //if it's got a private ip address it can only be accessed from some network.
-          //otherwise, it's presumably a publically accessable address.
-          var scope = (
-            item.internal ? 'device'
-            : ip.isPrivate(item.address) ? 'local'
-            : 'public'
-          )
-
-          return {
-            host: item.address,
-            port: getPort(service),
-            scope: [scope],
-            transform: 'shs'
-          }
-        })
-      }
-    }).reduce((result, obj) => {
-      // This `reduce()` step is necessary because we need to return an object
-      // rather than an array. There may be a simpler way to do this.
-      result[obj.service] = obj.interfaces
-      return result
-    }, {})
-  }
-
-  return incoming
-}
